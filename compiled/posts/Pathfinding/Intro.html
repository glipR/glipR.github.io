---
permalink: Pathfinding/Intro
---

<html lang="en-US">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Computers from A to B | glipR.dev</title>
<meta name="generator" content="Jekyll v3.8.5">
<meta property="og:title" content="Computers from A to B">
<meta property="og:locale" content="en_US">
<meta name="description" content="An introduction and Natural Search Algorithms">
<meta property="og:description" content="An introduction and Natural Search Algorithms">
<link rel="canonical" href="https://blog.glipr.dev/Pathfinding/Intro">
<meta property="og:url" content="https://blog.glipr.dev/Pathfinding/Intro">
<meta property="og:site_name" content="blog.glipR.dev">
<script type="application/ld+json">
{"@type":"WebPage","headline":"Computers from A to B","url":"https://blog.glipr.dev/Pathfinding/Intro","description":"An introduction and Natural Search Algorithms","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- Add FA icon/font family before anything else -->
    <script src="https://kit.fontawesome.com/cad86dcf3d.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link href="https://vjs.zencdn.net/7.6.0/video-js.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/style.css">
    <script src="https://code.jquery.com/jquery-3.3.0.min.js" integrity="sha256-RTQy8VOmNlT6b2PIRur37p6JEBZUE7o8wPgMvu18MC4=" crossorigin="anonymous"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
    <!--[if lt IE 9]>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" integrity="sha256-3Jy/GbSLrg0o9y5Z5n1uw0qxZECH7C6OQpVBgNFYa0g=" crossorigin="anonymous"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

</head>
<body>

    <header>
        <h1>Computers from A to B</h1>
        <p>An introduction and Natural Search Algorithms</p>
    </header>

    <div id="banner">
        <!-- Yellow Banner (Socials and Specific Links) -->
        <span id="logo"></span>

        <a href="https://github.com/glipR/glipR.github.io" class="button fork"><strong>View On GitHub</strong></a>
    </div><!-- end banner -->

    <div class="wrapper">
        <nav><ul>
            <!-- Auto filled navigation. -->
            
            
        </ul></nav>
        <section style="height: 354px;">
            <!-- Inner Content -->
            
    <h1>Why should I care?</h1>
<p>It's hard to fathom how much we rely on computer algorithms to get around these days,
and how much computational pathfinding is built in to many of the problems we solve,
that aren't just 'get from here to there'.</p>
<p>Do you remember the days of Melways, and other obscenely large books, containing just maps of your local area?
There's obviously a reason those all seemed to vanish in a matter of years, and that's because
we now have a little device which tells where to go, with better accuracy and more knowledge
of the current road state than a book could ever encapsulate.</p>
<div class="row">
<p><div class="col-md-6 col-xs-12">
    On the contrary, we've all seen times where this <em>reliance</em> on algorithms has served us poorly,
    or at the very least has confused us to see such a bad solution to a simple problem.
</div>
<div class="col-md-6 col-xs-12">
    <img src="https://media.giphy.com/media/8vzg9PiyeBGgAxAs6d/giphy.gif" />
</div></p>
</div>
<p>However, if you don't care how your little machine does all the things for you,
hopefully I can at least convince you that the discussion and evolution of these algorithms is beautiful,
and applicable in many other algorithmic problem areas.</p>
<p><div class='row section_div'><div class='col-md-9 col-xs-12'><video id='video_1' class='video-js vjs-default-skin vjs-fluid vjs-big-play-centered' controls preload='auto'><source src='/assets/videos/Pathfinding/highlights/480p.mp4' type='video/mp4' label='480p' selected='true'><p class='vjs-no-js'>
    To view this video please enable JavaScript, and consider upgrading to a web browser that
    <a href='https://videojs.com/html5-video-support/' target='_blank'>supports HTML5 video</a>
</p></video>            </div><div class='col-md-3 col-xs-12'><div class='section_choice' data_time='0'><p>BFS Graphs</p></div> <div class='section_choice' data_time='24'><p>Interesting Puzzle</p></div> <div class='section_choice' data_time='34'><p>Jump Point Search</p></div> <div class='section_choice' data_time='45'><p>LPA Star</p></div></div></div><span class='video_description' markdown='1'>
</span></p>
<h1>The general problem</h1>
<p>One of the amazing things about discussing pathfinding algorithms
is that pathfinding is something we do multiple times a day, without assistance from technology,
and so it is very intuitive to discuss topics here that might have seemed more abstract in a different problem domain.</p>
<p>The key difference here is that while we pathfind often on a very small scale,
we need fast computer algorithms to give us extremely optimal paths, or paths over incredibly large domain sizes.</p>
<p>While you might have a particular image of a pathfinding algorithm telling you whether to turn left or go straight at the lights, it does help to abstract the problem a little bit, so that we can use those same algorithms in surprisingly varied problem domains.</p>
<p>We'll define any pathfinding problem to contain two points of interest in a space:
A <em>start</em> point and an <em>end</em> goal.</p>
<p>We aim to begin at the start point, and via a process of movements between intermediate points, end up at the <em>end</em> goal.</p>
<p>We might modify this definition later, to include some more interesting problems (multiple starts, multiple goals, path weighting, etc.), but for now this is more than enough to discuss baby's first pathfinding algorithm :)</p>
<p><div class='row section_div'><div class='col-md-9 col-xs-12'><video id='video_2' class='video-js vjs-default-skin vjs-fluid vjs-big-play-centered' controls preload='auto'><source src='/assets/videos/Pathfinding/generic_graph/1440p.mp4' type='video/mp4' label='1440p' selected='false'>
<source src='/assets/videos/Pathfinding/generic_graph/720p.mp4' type='video/mp4' label='720p' selected='false'>
<source src='/assets/videos/Pathfinding/generic_graph/480p.mp4' type='video/mp4' label='480p' selected='true'><p class='vjs-no-js'>
    To view this video please enable JavaScript, and consider upgrading to a web browser that
    <a href='https://videojs.com/html5-video-support/' target='_blank'>supports HTML5 video</a>
</p></video>            </div><div class='col-md-3 col-xs-12'><div class='section_choice' data_time='0'><p>Start and End</p></div> <div class='section_choice' data_time='5'><p>Add Intermediate Points</p></div> <div class='section_choice' data_time='9'><p>The Wider Domain</p></div></div></div><span class='video_description' markdown='1'>
</span></p>
<p>From now on I'll call these 'points' <em>vertices</em> (<em>vertex</em> singular), and the connections between these <em>edges</em>.
This is because the current definition shares its likeness with mathematical graphs,
which has the same terminology.</p>
<p>When writing algorithms, most of the time the cheapest/easiest queries to make on such a graph will be:</p>
<ul>
<li>What are the start and end vertices?</li>
<li>What are the neighbours of vertex <code>a</code>?</li>
<li>What edge(s) can I uses to get from vertex <code>a</code> to <code>b</code>?</li>
</ul>
<p>And so we'll write algorithms mostly in terms of these queries
(However I will try to keep away from code of any form,
most algorithms can be explained in plain english rather succinctly).</p>
<h1>Keep it Simple Stupid</h1>
<h2>Natural Approach</h2>
<p>So let's do it! Let's get from A to B! Let's first try to think how you'd approach this situation, and try as best you can to put that into algorithmic terms, using the queries mentioned above where  appropriate. Here are some flashing graphs, see what your brain first does when it tries to find a path between the red and green dots/squares.</p>
<p><video id='video_3' class='video-js vjs-default-skin vjs-fluid vjs-big-play-centered' controls preload='auto'><source src='/assets/videos/Pathfinding/flashing_graphs/1440p.mp4' type='video/mp4' label='1440p' selected='false'>
<source src='/assets/videos/Pathfinding/flashing_graphs/720p.mp4' type='video/mp4' label='720p' selected='false'>
<source src='/assets/videos/Pathfinding/flashing_graphs/480p.mp4' type='video/mp4' label='480p' selected='true'><p class='vjs-no-js'>
    To view this video please enable JavaScript, and consider upgrading to a web browser that
    <a href='https://videojs.com/html5-video-support/' target='_blank'>supports HTML5 video</a>
</p></video>            <span class='video_description' markdown='1'>
<p>There's lots of different graph types, aren't there?</p>
</span></p>
<p>For me personally, when I'm flashed a graph like the ones above,
I kind of 'search out' from the start vertex. That is, I look at the vertices close to the start vertex,
then looking out a bit further, etc., until I find the end vertex.</p>
<p>Obviously my brain doesn't follow that to a tee,
but for smaller graphs that's where my mind wanders most of the time.</p>
<p>For a human, this might not make sense for increasingly big graphs, because we need to keep track of all of the current vertices we are looking at.
Let's not worry about this for now, and try and turn it into an algorithm!</p>
<h2>Formalizing</h2>
<p>Rather than keeping these algorithms completely within our brains,
let's turn this into a set of simple and unambiguous steps.</p>
<p>First, we'll have the notion of vertices we are currently looking at.
We'll call these the <code>expanding</code> nodes (Still applicable here, but moreso because its related to later algorithms.)</p>
<p>The first algorithm we begin 'expanding' from is the start node</p>
<div class="codehilite"><pre><span></span><span class="n">expanding</span> <span class="o">=</span> <span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>
</pre></div>


<p>Next, and most importantly, we need to formalise what 'searching out' is, and in what order we search out from vertices.</p>
<p>First of all, I think it's most reasonable to define 'searching out' as appending all of a vertex's neighbours to the <code>expanding</code> set (At least those that we haven't already been expanded).</p>
<p>After that, I think there are two natural ways order our 'expansion' of these vertices:</p>
<ol>
<li>Expand the vertices in zones dependant on distance from the start vertex. (Favouring Breadth of Search)<blockquote>
<p>More what I was describing with my approach</p>
</blockquote>
</li>
<li>Keep expanding neighbours until we hit the end of a graph, then begin backtracking (Favouring Depth of Search)<blockquote>
<p>A good approach for testing whether a path exists, but maybe not for generating the shortest one.</p>
</blockquote>
</li>
</ol>
<p>I'm going to write up the answer for (1), but it'd be a good exercise to try the same for (2):</p>
<div class="codehilite"><pre><span></span><span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
    <span class="n">vertex</span><span class="o">.</span><span class="n">expanded</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">expanding</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
<span class="k">while</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">expanded</span><span class="p">:</span>
    <span class="n">new_expanding</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">expanding</span><span class="p">:</span>
        <span class="n">vertex</span><span class="o">.</span><span class="n">expanded</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">expanding</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbours</span><span class="p">(</span><span class="n">vertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">neighbour</span><span class="o">.</span><span class="n">expanded</span><span class="p">:</span>
                <span class="n">new_expanding</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span>
    <span class="n">expanding</span> <span class="o">=</span> <span class="n">new_expanding</span>
</pre></div>


<p>So, to keep it in simple english, we first look at all vertices which are 0 distance from the start,
then 1 distance from the start, then 2 distance, and so on, until we find the end vertex.</p>
<p>We can generate all n-distance vertices from the graph, after knowing the (n-1)-distance vertices, by visiting all of their neighbours, and marking any that we haven't seen yet.</p>
<p>This is because the distance from the start between any two adjacent vertices is at most 1.
(Otherwise we'd be able to generate a shorter distance to the start vertex than we'd originally defined)</p>
<h1>Divining a path</h1>
<p>So we can locate the end all well and good, but how do we create a path now that we've searched the entire way?</p>
<p>I'll pose two solutions here, each which assume some computation/memory has been going on as we've been searching the graph.</p>
<h2>Closing the distance</h2>
<p>Rather than pathing from the start to the end, let's traverse the other way!
Let's assume that while we've been searching, we've been keeping track off the distance from the start node for each vertex we expand.</p>
<p><em>This would be relatively simple, as we can just keep a counter in the </em><code>while</code><em> loop</em></p>
<p>Next, I don't think its too much of a mental leap to say that a good path from the end to the start is one that always reduces the distance to the start vertex as you move across the path.</p>
<p>Such a path can always exist, and we can generate it algorithmically:</p>
<ul>
<li>Start at the end vertex.</li>
<li>Look at all of the current vertex's neighbours</li>
<li>There <strong>must</strong> be some neighbour where the distance from the start vertex decreases by 1 (*)</li>
<li>Move to this new vertex</li>
<li>Repeat back to the second step</li>
<li>Once we reach a vertex with distance 0 from the start vertex, we must have reached the start vertex.</li>
</ul>
<p>(*) The above is true because for there to be an $n$ length path from the start vertex to this one,
we must have an $n-1$ length path from the start vertex to one of its neighbours, followed by a 1 length path from that neighbour to our vertex.</p>
<p>This neighbour must have distance $n-1$, as if it was some $k &lt; n-1$, then we'd have a $k + 1 &lt; n$ length path from the start vertex to our vertex. (Drawing a diagram helps here if you are stuck)</p>
<h2>Remembering your roots</h2>
<p>Let's instead say that as we are searching, each vertex remembers how it was discovered (For example what vertex in the previous iteration caused it to be <code>expanded</code>.)
We'll call this the vertex's <code>parent</code> (Because it gave 'birth' to this new vertex)</p>
<p>Then we can simply algorithmically generate a path from end to start by:</p>
<ul>
<li>Start at the end vertex.</li>
<li>Move back to the parent vertex.</li>
<li>Repeat until we hit the start vertex.</li>
</ul>
<p>We are guaranteed to hit the start vertex, because that's where the entire search originated from.</p>
<h1>An unlikely application</h1>
<p>Now that we've completed our first pathfinding algorithm (🎉 Woo! 🎉),
Lets take a break from the abstract and tackle a real problem.</p>
<p>One puzzle from the game <a href="https://en.wikipedia.org/wiki/Professor_Layton_and_the_Curious_Village">Professor Layton and the Curious Village</a> (A <em>treasure trove</em> of algorithmically enticing puzzles) is as follows:</p>
<p>We have 3 chickens, and 3 wolves on one side of a river.
All of the animals want to reach the other side of the river, luckily they have a raft!</p>
<p>There are two main rules which restrict the solutions to this problem:</p>
<ol>
<li>The raft only fits two animals at once (And there needs to be an animal on board for the raft to move)</li>
<li>If at any point either side of the river has more wolves than chickens, then the chickens get eaten!</li>
</ol>
<p>Is there a set of moves that take all animals from one side of the river to the other?</p>
<p><strong><em>Video, with subtext:</em></strong></p>
<p><em>This problem pops up in a number of other areas, but I'm attributing it to this game so I have an excuse to use the nice artwork. Seriously play this game.</em></p>
<p>As a pathfinding problem, the solution doesn't exactly stick out immediately.
Sure the problem is asking for a path, but this path is just continual moves between two different places!
So what next? One thing I mentioned when we were first discussing pathfinding as a solution to other problems is that often times we need to abstract the solution to weird definitions of what a vertex and edge is, in order for our algorithms to be appropriate.</p>
<p>In this example, rather than thinking of our vertices as left and right of the river (Actual locations in the puzzle), lets think of each vertex we are moving to and from, to be a bit more specific.</p>
<p>It should encode the location of the wolves, chickens, as well as the raft into a single point.
This would ensure that two different <em>game states</em> are different, even if the raft is currently at the right side of the river in both.</p>
<p>One simple way would be to simply encode a string, where the first 3 characters would represent the wolf locations, the next three the chickens, and the last 1 the raft's location:</p>
<ul>
<li>LLR RRL R would mean 2 wolves and 1 chicken on the left, with the raft and the rest on the right</li>
<li>RRR LLL L would mean wolves on the right, chickens on the left, raft on the left.</li>
</ul>
<p>Notice how when we describe the encoding, we don't actually care which chicken/wolf is on which side, we only talk quantities. This is because the problem state isn't affected by the location of individual chickens, rather the rules are only affected by <strong>how many</strong> chickens/wolves there are on either side (As well as the raft).</p>
<p>So instead of encoding each chicken/wolf location, we can reduce the number of vertices greatly by simply decoding a game state to number how many chickens/wolves are on the left side, as well as how many rafts are on the left side (0 or 1):</p>
<ul>
<li>210 would be equivalent to LLR RRL R (or LRL LRR R, or many others)</li>
<li>031 would be equivalent to RRR LLL L (and thats the only encoding in the previous schema)</li>
</ul>
<p>Overall we've reduced our vertex amount from $2^7 = 128$ to $4 * 4 * 2 = 32$.
Now that we've got a tight definition of valid vertices, we can define an edge between two vertices to mean a valid transition between the two decoded states existing!</p>
<p>Now, we can construct a solution to our problem by:</p>
<ol>
<li>Constructing a graph describing the entire problem state and how we can move around it</li>
<li>Starting at vertex 331 (All on the left)</li>
<li>Using our previous algorithm to pathfind to vertex 000 (All on the right)</li>
<li>Decode such a path into actual movements in the puzzle</li>
</ol>
<p><em>Note that vertex 001 would technically also satisfy a solution, but is unreachable.</em></p>
<p>So let's do it! Let's construct the graph based on our previous rules.
First, we'll remove any vertices whose state violates rule 2 (More wolves than chickens),
then we'll add edges which are valid state transitions ($0 &lt; x &lt;= 2$ animals changing, raft direction changes)</p>
<p><strong><em>VIDEO</em></strong></p>
<p>Next, we can pathfind using our algorithm described above:</p>
<p><strong><em>VIDEO</em></strong></p>
<p>This gives us that path 331 -&gt; ... -&gt; 000,
Which we can decode to:</p>
<ul>
<li>Move across x and y</li>
<li>Take back z and w</li>
</ul>

        </section>
        <footer>
            <p><small>Hosted on GitHub Pages — Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
        </footer>
    </div>

    <script src='https://vjs.zencdn.net/7.6.0/video.js'></script>
    <script src="https://unpkg.com/silvermine-videojs-quality-selector/dist/js/silvermine-videojs-quality-selector.min.js"></script>
    <script src="/assets/js/main.js"></script>
</body>
</html>